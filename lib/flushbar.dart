library flushbar;

import 'package:flutter/material.dart';
import 'dart:async';

/// A custom widget so you can notify your user when you fell like he needs an explanation.
/// This is inspired on a custom view (Flashbar)[https://github.com/aritraroy/Flashbar] created for android.
///
/// [_mainScreenChild] Any widget that the Flushbar will appear in front of. (Your main screen for example).
/// [title] The title displayed to the user (can be changed using [changeTitle]).
/// [message] The message displayed to the user.
/// [iconData] The icon indication what king of message you are displaying.
/// [titleText] If you need something more personalized, pass a [Text] widget to this variable. [title] will be ignored until this variable is null.
/// [notificationText] If you need something more personalized, pass a [Text] widget to this variable. [message] will be ignored until this variable is null.
/// [iconColor] The color painting [iconData].
/// [backgroundColor] Flushbar background color. Will be ignored if [backgroundGradient] is not null.
/// [shadowColor] The shadow generated by the Flushbar. Leave it null if you don't want a shadow.
/// [backgroundGradient] Flushbar background gradient. Makes [backgroundColor] be ignored.
/// [mainButton] A [FlatButton] widget if you need an action from the user.
/// [flushbarPosition] Flushbar can be based on [FlushbarPosition.TOP] or on [FlushbarPosition.BOTTOM] of your screen. [FlushbarPosition.BOTTOM] is the default.
/// [iconPosition] The icon can take [IconPosition.START] or [IconPosition.END]. [IconPosition.START] is default.
/// [duration] How long until Flushbar will hide itself (be dismissed). To make it indefinite, leave it null.
/// [isDismissible] Determines if the user can swipe to dismiss the bar. It is recommended that you set [duration] != null if [isDismissible] == false.
/// [forwardAnimationCurve] The [Curve] animation used when show() is called. [Curves.easeOut] is default.
/// [reverseAnimationCurve] The [Curve] animation used when dismiss() is called. [Curves.fastOutSlowIn] is default.
/// [linearProgressIndicator] An optional [LinearProgressIndicator] ideal when loading or uploading something
///
/// ATTENTION
/// Can't change [_mainScreenChild] after instantiation.
/// Can't change [flushbarPosition] after instantiation.
/// Can't change [forwardAnimationCurve] or [reverseAnimationCurve] curves after instantiation.
/// Use the change...(x) functions to change properties. If you call them directly, the widget won't redraw and changes won't take affect.
/// The change...(x) functions will take affect immediately. Make sure Flushbar is dismissed when changing properties.

class Flushbar extends StatefulWidget {
  Flushbar(this._mainScreenChild, this.title, this.message,
      {this.iconData = Icons.info_outline,
        this.titleText,
        this.notificationText,
        this.iconColor = Colors.blue,
        this.backgroundColor = Colors.black,
        this.shadowColor,
        this.backgroundGradient,
        this.mainButton,
        this.flushbarPosition = FlushbarPosition.BOTTOM,
        this.iconPosition = IconPosition.START,
        this.duration,
        this.isDismissible = true,
        this.forwardAnimationCurve = Curves.easeOut,
        this.reverseAnimationCurve = Curves.fastOutSlowIn,
        this.linearProgressIndicator});

  Widget _mainScreenChild;
  String title;
  String message;
  Text titleText;
  Text notificationText;
  Color iconColor;
  Color backgroundColor;
  Color shadowColor;
  Gradient backgroundGradient;
  IconData iconData;
  FlatButton mainButton;
  FlushbarPosition flushbarPosition;
  IconPosition iconPosition;
  Duration duration;
  Curve forwardAnimationCurve;
  Curve reverseAnimationCurve;
  LinearProgressIndicator linearProgressIndicator;
  bool isDismissible;

  _FlushbarState flushbar;

  /// The change...() functions will redraw the widget immediately. Make sure the
  /// flushbar is dismissed when this happens otherwise the user will be confused.
  void changeTitle(String title) {
    flushbar._changeTitle(title);
  }

  void changeMessage(String message) {
    flushbar._changeMessage(message);
  }

  void changeTitleText(Text titleText) {
    flushbar._changeTitleText(titleText);
  }

  void changeNotificationText(Text notificationText) {
    flushbar._changeNotificationText(notificationText);
  }

  void changeBackgroundColor(Color backgroundColor) {
    flushbar._changeBackgroundColor(backgroundColor);
  }

  void changeShadowColor(Color shadowColor) {
    flushbar._changeShadowColor(shadowColor);
  }

  void changeBackgroundGradient(Gradient backgroundGradient) {
    flushbar._changeBackgroundGradient(backgroundGradient);
  }

  void changeMainButton(FlatButton mainButton) {
    flushbar._changeMainButton(mainButton);
  }

  void changeIconPosition(IconPosition iconPosition) {
    flushbar._changeIconPosition(iconPosition);
  }

  void changeDuration(Duration duration) {
    flushbar._changeDuration(duration);
  }

  void changeLinearProgressIndicator(
      LinearProgressIndicator linearProgressIndicator) {
    flushbar._changeLinearProgressIndicator(linearProgressIndicator);
  }

  void changeIsDismissible(bool isDismissible) {
    flushbar._changeIsDismissible(isDismissible);
  }

  void changeIcon(IconData iconData) {
    flushbar._changeIcon(iconData);
  }

  void changeIconColor(Color iconColor) {
    flushbar._changeIconColor(iconColor);
  }

  /// Makes the flushbar visible to the user starting all animations.
  void show() {
    flushbar.show();
  }

  /// Hides the flushbar pausing all the animation.
  void dismiss() {
    flushbar.dismiss();
  }

  /// Releases resources and makes the current flushbar unusable
  void purge() {
    flushbar.purge();
  }

  /// Checks if the flushbar is visible
  bool isShowing() {
    return flushbar.isShowing();
  }

  /// Checks if the flushbar is hidden
  bool isDismissed() {
    return flushbar.isDismissed();
  }

  @override
  State createState() {
    flushbar = new _FlushbarState(_mainScreenChild, title, message,
        titleText: titleText,
        notificationText: notificationText,
        iconData: iconData,
        iconColor: iconColor,
        backgroundColor: backgroundColor,
        shadowColor: shadowColor,
        backgroundGradient: backgroundGradient,
        mainButton: mainButton,
        flushbarPosition: flushbarPosition,
        iconPosition: iconPosition,
        duration: duration,
        isDismissible: isDismissible,
        forwardAnimationCurve: forwardAnimationCurve,
        reverseAnimationCurve: reverseAnimationCurve,
        linearProgressIndicator: linearProgressIndicator);

    return flushbar;
  }
}

class _FlushbarState extends State<Flushbar> with TickerProviderStateMixin {
  _FlushbarState(this._backChild, this.title, this.message,
      {this.titleText,
        this.notificationText,
        this.iconData,
        this.iconColor,
        this.backgroundColor,
        this.shadowColor,
        this.backgroundGradient,
        this.mainButton,
        this.flushbarPosition,
        this.iconPosition,
        this.duration,
        this.isDismissible = true,
        this.forwardAnimationCurve,
        this.reverseAnimationCurve,
        this.linearProgressIndicator});

  Widget _backChild;
  String title;
  String message;
  Text titleText;
  Text notificationText;
  IconData iconData;
  Color iconColor;
  Color backgroundColor;
  Color shadowColor;
  Gradient backgroundGradient;
  FlatButton mainButton;
  FlushbarPosition flushbarPosition;
  IconPosition iconPosition;
  Duration duration;
  Curve forwardAnimationCurve;
  Curve reverseAnimationCurve;
  LinearProgressIndicator linearProgressIndicator;
  bool isDismissible;

  AnimationController _popUpController;
  Animation<Alignment> _popUpAnimation;
  _IconAnimationAware animationAwareIcon;
  BoxShadow _boxShadow;

  final Widget _emptyWidget = SizedBox(width: 0.0, height: 0.0);
  EdgeInsets barInsets;

  void _changeTitle(String title) {
    setState(() {
      this.title = title;
    });
  }

  void _changeMessage(String message) {
    setState(() {
      this.message = message;
    });
  }

  void _changeTitleText(Text titleText) {
    setState(() {
      this.titleText = titleText;
    });
  }

  void _changeNotificationText(Text notificationText) {
    setState(() {
      this.notificationText = notificationText;
    });
  }

  void _changeBackgroundColor(Color backgroundColor) {
    setState(() {
      this.backgroundColor = backgroundColor;
    });
  }

  void _changeShadowColor(Color shadowColor) {
    setState(() {
      this.shadowColor = shadowColor;
      _setBoxShadow();
    });
  }

  void _changeBackgroundGradient(Gradient backgroundGradient) {
    setState(() {
      this.backgroundGradient = backgroundGradient;
    });
  }

  void _changeMainButton(FlatButton mainButton) {
    setState(() {
      this.mainButton = mainButton;
    });
  }

  void _changeIconPosition(IconPosition iconPosition) {
    setState(() {
      this.iconPosition = iconPosition;
    });
  }

  void _changeDuration(Duration duration) {
    setState(() {
      this.duration = duration;
    });
  }

  void _changeLinearProgressIndicator(
      LinearProgressIndicator linearProgressIndicator) {
    setState(() {
      this.linearProgressIndicator = linearProgressIndicator;
    });
  }

  void _changeIsDismissible(bool isDismissible) {
    setState(() {
      this.isDismissible = isDismissible;
    });
  }

  void _changeIcon(IconData iconData) {
    animationAwareIcon.changeIcon(iconData);
  }

  void _changeIconColor(Color iconColor) {
    animationAwareIcon.changeIconColor(iconColor);
  }

  void show() {
    _popUpController.forward();
    animationAwareIcon.show();
  }

  void dismiss() {
    if (!_popUpController.isAnimating) {
      _popUpController.reverse();
    }
    animationAwareIcon.dismiss();
  }

  bool isShowing() {
    return _popUpController.isCompleted;
  }

  bool isDismissed() {
    return _popUpController.isDismissed;
  }

  void purge() {
    dispose();
  }

  void _resetAnimations() {
    _popUpController.reset();
    animationAwareIcon.dismiss();
  }

  List<BoxShadow> _getBoxShadowList() {
    if (_boxShadow != null) {
      return [_boxShadow];
    } else {
      return null;
    }
  }

  @override
  void initState() {
    super.initState();

    Alignment initialAlignment;
    Alignment endAlignment;

    switch (flushbarPosition) {
      case FlushbarPosition.TOP:
        {
          initialAlignment = new Alignment(-1.0, -2.0);
          endAlignment = new Alignment(-1.0, -1.0);
          barInsets = EdgeInsets.only(top: 24.0, bottom: 8.0);
          _setBoxShadow();

          break;
        }
      case FlushbarPosition.BOTTOM:
        {
          initialAlignment = new Alignment(-1.0, 2.0);
          endAlignment = new Alignment(-1.0, 1.0);
          barInsets = EdgeInsets.only(top: 0.0);
          _setBoxShadow();

          break;
        }
    }

    animationAwareIcon = new _IconAnimationAware(iconData, iconColor);

    _popUpController =
        AnimationController(vsync: this, duration: Duration(seconds: 1));

    _popUpAnimation = AlignmentTween(begin: initialAlignment, end: endAlignment)
        .animate(new CurvedAnimation(
        parent: _popUpController,
        curve: forwardAnimationCurve,
        reverseCurve: reverseAnimationCurve));

    _popUpAnimation.addStatusListener((animationStatus) {
      print(animationStatus.toString());
      if (animationStatus == AnimationStatus.completed) {
        if (duration != null) {
          new Timer(duration, () {
            _popUpController.reverse();
          });
        }
      }
    });

    _popUpController.addListener(() {
      setState(() {});
    });

    _popUpController.forward();
  }

  void _setBoxShadow() {
    switch (flushbarPosition) {
      case FlushbarPosition.TOP:
        {
          if (shadowColor != null) {
            _boxShadow = BoxShadow(
              color: shadowColor,
              offset: Offset(0.0, 2.0),
              blurRadius: 3.0,
            );
          }

          break;
        }
      case FlushbarPosition.BOTTOM:
        {
          if (shadowColor != null) {
            _boxShadow = BoxShadow(
              color: shadowColor,
              offset: Offset(0.0, -0.7),
              blurRadius: 3.0,
            );
          }

          break;
        }
    }
  }

  @override
  void dispose() {
    _popUpController.dispose();
    animationAwareIcon.purge();
    super.dispose();
  }

  /// This string is a workaround until Dismissible supports a returning item
  String dismissibleKeyGen = "";

  Widget _getFlushbar() {
    if (isDismissible) {
      return new Dismissible(
        key: Key(dismissibleKeyGen),
        onDismissed: (dismissDirection) {
          dismissibleKeyGen += "1";
          _resetAnimations();
        },
        child: _generateFlushbar(),
      );
    } else {
      return _generateFlushbar();
    }
  }

  Widget _generateFlushbar() {
    if (iconPosition == IconPosition.START) {
      return new DecoratedBox(
        decoration: new BoxDecoration(
          color: backgroundColor,
          gradient: backgroundGradient,
          boxShadow: _getBoxShadowList(),
        ),
        child: new Padding(
          padding: barInsets,
          child: new Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              linearProgressIndicator ?? _emptyWidget,
              new Row(
                mainAxisSize: MainAxisSize.max,
                children: <Widget>[
                  new Expanded(
                    flex: 1,
                    child: new Padding(
                      padding: const EdgeInsets.only(
                          top: 8.0, left: 8.0, bottom: 8.0),
                      child: animationAwareIcon,
                    ),
                  ),
                  new Expanded(
                    flex: 5,
                    child: new Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      mainAxisSize: MainAxisSize.min,
                      children: <Widget>[
                        new Padding(
                          padding: const EdgeInsets.only(
                              top: 16.0, left: 8.0, right: 8.0),
                          child: titleText ?? _getDefaultTitleText(),
                        ),
                        new Padding(
                          padding: const EdgeInsets.all(8.0),
                          child:
                          notificationText ?? _getDefaultNotificationText(),
                        ),
                        new Align(
                          heightFactor: 1.0,
                          alignment: Alignment.centerRight,
                          child: new Padding(
                            padding: const EdgeInsets.only(right: 8.0),
                            child: _getMainActionButton(),
                          ) ??
                              _emptyWidget,
                        ),
                      ],
                    ),
                  )
                ],
              ),
            ],
          ),
        ),
      );
    } else {
      return new DecoratedBox(
        decoration: new BoxDecoration(
          color: backgroundColor,
          gradient: backgroundGradient,
          boxShadow: _getBoxShadowList(),
        ),
        child: new Padding(
          padding: barInsets,
          child: new Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              linearProgressIndicator ?? _emptyWidget,
              new Row(
                mainAxisSize: MainAxisSize.max,
                children: <Widget>[
                  new Expanded(
                    flex: 4,
                    child: new Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      mainAxisSize: MainAxisSize.min,
                      children: <Widget>[
                        new Padding(
                          padding: const EdgeInsets.only(
                              top: 16.0, left: 8.0, right: 8.0),
                          child: titleText ?? _getDefaultTitleText(),
                        ),
                        new Padding(
                          padding: const EdgeInsets.all(8.0),
                          child:
                          notificationText ?? _getDefaultNotificationText(),
                        ),
                      ],
                    ),
                  ),
                  new Expanded(
                    flex: 1,
                    child: new Padding(
                      padding: const EdgeInsets.only(
                          top: 8.0, left: 8.0, bottom: 8.0, right: 16.0),
                      child: animationAwareIcon,
                    ),
                  ),
                ],
              ),
              new Align(
                heightFactor: 1.0,
                alignment: Alignment.centerRight,
                child: _getMainActionButton() ?? _emptyWidget,
              ),
            ],
          ),
        ),
      );
    }
  }

  Text _getDefaultTitleText() {
    return new Text(
      title,
      style: TextStyle(
          fontSize: 16.0, color: Colors.white, fontWeight: FontWeight.bold),
    );
  }

  Text _getDefaultNotificationText() {
    return new Text(
      message,
      style: TextStyle(fontSize: 16.0, color: Colors.white),
    );
  }

  FlatButton _getMainActionButton() {
    if (mainButton != null) {
      return mainButton;
    } else {
      return null;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: <Widget>[
        _backChild,
        new Align(
          heightFactor: 1.0,
          child: new AlignTransition(
            alignment: _popUpAnimation,
            child: _getFlushbar(),
          ),
        )
      ],
    );
  }
}

class _IconAnimationAware extends StatefulWidget {
  _IconAnimationAware(this._iconData, this._iconColor);

  IconData _iconData;
  Color _iconColor;
  _IconAnimationAwareState state;

  void changeIcon(IconData iconData) {
    state.changeIcon(iconData);
  }

  void changeIconColor(Color iconColor) {
    state.changeIconColor(iconColor);
  }

  void show() {
    state.show();
  }

  void dismiss() {
    state.dismiss();
  }

  void purge() {
    state.dispose();
  }

  @override
  State createState() {
    state = new _IconAnimationAwareState(_iconData, _iconColor);
    return state;
  }
}

class _IconAnimationAwareState extends State<_IconAnimationAware>
    with TickerProviderStateMixin {
  _IconAnimationAwareState(this._iconData, this._iconColor);

  IconData _iconData;
  Color _iconColor;
  final Duration _duration = Duration(seconds: 1);

  AnimationController _fadeIconController;
  Animation<Color> _fadeIconAnimation;

  void changeIcon(IconData iconData) {
    setState(() {
      _iconData = iconData;
    });
  }

  void changeIconColor(Color iconColor) {
    setState(() {
      _iconColor = iconColor;
      _fadeIconAnimation =
          new ColorTween(begin: _iconColor, end: Colors.transparent).animate(
            new CurvedAnimation(
              parent: _fadeIconController,
              curve: Curves.linear,
            ),
          );
    });
  }

  void show() {
    _fadeIconController.forward();
  }

  void dismiss() {
    _fadeIconController.reset();
  }

  void purge() {
    dispose();
  }

  @override
  void initState() {
    _fadeIconController = AnimationController(vsync: this, duration: _duration);
    _fadeIconAnimation =
        ColorTween(begin: _iconColor, end: Colors.transparent).animate(
          new CurvedAnimation(
            parent: _fadeIconController,
            curve: Curves.linear,
          ),
        );

    _fadeIconController.addStatusListener((status) {
      if (status == AnimationStatus.completed) {
        _fadeIconController.reverse();
      }
      if (status == AnimationStatus.dismissed) {
        _fadeIconController.forward();
      }
    });

    _fadeIconController.addListener(() {
      setState(() {
        _iconColor = _fadeIconAnimation.value;
      });
    });

    _fadeIconController.forward();
    super.initState();
  }

  @override
  void dispose() {
    _fadeIconController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return new Padding(
      padding: const EdgeInsets.only(top: 8.0, right: 8.0, bottom: 8.0),
      child: new Icon(
        _iconData,
        color: _iconColor,
        size: 28.0,
      ),
    );
  }
}

/// Indicates if flushbar is going to start at the [TOP] or at the [BOTTOM]
enum FlushbarPosition { TOP, BOTTOM }

/// Indicates if icon is at the [START] or [END] position
enum IconPosition { START, END }

