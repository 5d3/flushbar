library flushbar;

import 'package:flutter/material.dart';
import 'dart:async';

typedef void FlushbarStatusCallback(FlushbarStatus status);

/// A custom widget so you can notify your user when you fell like he needs an explanation.
/// This is inspired on a custom view (Flashbar)[https://github.com/aritraroy/Flashbar] created for android.
///
/// [title] The title displayed to the user (can be changed using [changeTitle]).
/// [message] The message displayed to the user.
/// [titleText] If you need something more personalized, pass a [Text] widget to this variable. [title] will be ignored if this variable is not null.
/// [messageText] If you need something more personalized, pass a [Text] widget to this variable. [message] will be ignored if this variable is not null.
/// [icon] The [Icon] indication what kind of message you are displaying.
/// [backgroundColor] Flushbar background color. Will be ignored if [backgroundGradient] is not null.
/// [shadowColor] The shadow generated by the Flushbar. Leave it null if you don't want a shadow.
/// [backgroundGradient] Flushbar background gradient. Makes [backgroundColor] be ignored.
/// [mainButton] A [FlatButton] widget if you need an action from the user.
/// [duration] How long until Flushbar will hide itself (be dismissed). To make it indefinite, leave it null.
/// [isDismissible] Determines if the user can swipe to dismiss the bar. It is recommended that you set [duration] != null if [isDismissible] == false.
/// [forwardAnimationCurve] The [Curve] animation used when show() is called. [Curves.easeOut] is default.
/// [userInputTextField] Used when you want a user to input a text. Other widgets will be ignored until this goes back to being null.
/// [flushbarPosition] (final) Flushbar can be based on [FlushbarPosition.TOP] or on [FlushbarPosition.BOTTOM] of your screen. [FlushbarPosition.BOTTOM] is the default.
/// [reverseAnimationCurve] (final) The [Curve] animation used when dismiss() is called. [Curves.fastOutSlowIn] is default.
/// [linearProgressIndicator] (final) An optional [LinearProgressIndicator] ideal when loading or uploading something
///
/// ATTENTION
/// The changes will take effect only after you call commitChanges().
/// [flushbarPosition], [forwardAnimationCurve] and [reverseAnimationCurve] are immutable and can't be changed after instantiation.
/// Make sure you call purge() if you are discarding the Flushbar.
/// Call purge only if you are discarding the Flushbar.

class Flushbar extends StatefulWidget {
  Flushbar({
    this.title,
    this.message,
    this.titleText,
    this.messageText,
    this.icon,
    this.backgroundColor = const Color(0xFF303030),
    this.shadowColor,
    this.backgroundGradient,
    this.mainButton,
    this.duration,
    this.isDismissible = true,
    this.linearProgressIndicator,
    this.flushbarPosition = FlushbarPosition.BOTTOM,
    this.forwardAnimationCurve = Curves.easeOut,
    this.reverseAnimationCurve = Curves.fastOutSlowIn,
  });

  /// [onStatusChanged] A callback used to listen to Flushbar status [FlushbarStatus]. Set it using [setStatusListener()]
  FlushbarStatusCallback onStatusChanged;
  String title;
  String message;
  Text titleText;
  Text messageText;
  Color backgroundColor;
  Color shadowColor;
  Gradient backgroundGradient;
  Icon icon;
  FlatButton mainButton;
  Duration duration;
  LinearProgressIndicator linearProgressIndicator;
  bool isDismissible;
  TextFormField userInputTextField;

  final FlushbarPosition flushbarPosition;
  final Curve forwardAnimationCurve;
  final Curve reverseAnimationCurve;

  _FlushbarState flushbarState;

  /// Makes the flushbar visible to the user starting all animations.
  void show() {
    flushbarState._show();
  }

  /// Hides the flushbar pausing all the animation.
  void dismiss() {
    flushbarState._dismiss();
  }

  /// Draw the changes on screen
  void commitChanges() {
    flushbarState._commitChanges();
  }

  /// Releases resources and makes the current flushbar unusable
  void purge() {
    flushbarState._purge();
  }

  /// Checks if the flushbar is visible
  bool isShowing() {
    return flushbarState._isShowing();
  }

  /// Checks if the flushbar is hidden
  bool isDismissed() {
    return flushbarState._isDismissed();
  }

  @override
  State createState() {
    flushbarState = new _FlushbarState();

    return flushbarState;
  }
}

class _FlushbarState extends State<Flushbar> with TickerProviderStateMixin {
  _FlushbarState() {
    _animationStatusListener = (animationStatus) {
      switch (animationStatus) {
        case AnimationStatus.completed:
          {
            if (widget.onStatusChanged != null) {
              currentStatus = FlushbarStatus.SHOWING;
              widget.onStatusChanged(currentStatus);
            }
            _configureTimer();
            break;
          }

        case AnimationStatus.dismissed:
          {
            if (widget.onStatusChanged != null) {
              currentStatus = FlushbarStatus.DISMISSED;
              widget.onStatusChanged(currentStatus);
            }
            break;
          }

        case AnimationStatus.forward:
          {
            if (widget.onStatusChanged != null) {
              currentStatus = FlushbarStatus.IS_APPEARING;
              widget.onStatusChanged(currentStatus);
            }
            break;
          }

        case AnimationStatus.reverse:
          {
            if (widget.onStatusChanged != null) {
              currentStatus = FlushbarStatus.IS_HIDING;
              widget.onStatusChanged(currentStatus);
            }
            break;
          }
      }
    };
  }

  BoxShadow _boxShadow;
  FlushbarStatus currentStatus;
  Timer timer;

  AnimationController _popController;
  Animation<Alignment> _popAnimation;
  AnimationController _fadeController;
  Animation<double> _fadeAnimation;
  AnimationController _blinkController;
  Animation<double> _blinkAnimation;

  EdgeInsets barInsets;
  AnimationStatusListener _animationStatusListener;

  final Widget _emptyWidget = SizedBox(width: 0.0, height: 0.0);
  final double _initialOpacity = 1.0;
  final double _finalOpacity = 0.4;

  final Duration _duration = Duration(seconds: 1);

  void _show() {
    _popController.forward();
    _fadeController.forward();
  }

  void _dismiss() {
    if (!_popController.isAnimating) {
      _popController.reverse();
      _fadeController.reset();
    }
  }

  void _commitChanges() {
    if (!_isDismissed()) {
      _blinkController.forward();

      if (_isShowing()) {
        _configureTimer();
      }

      new Timer(Duration(milliseconds: 500), () {
        setState(() {});
      });
    } else {
      setState(() {});
    }
  }

  bool _isShowing() {
    return _popController.isCompleted;
  }

  bool _isDismissed() {
    return _popController.isDismissed;
  }

  void _purge() {
    currentStatus = FlushbarStatus.PURGED;
    widget.onStatusChanged(currentStatus);
    _popAnimation.removeStatusListener(_animationStatusListener);
    dispose();
  }

  void _resetAnimations() {
    _popController.reset();
    _fadeController.reset();
  }

  List<BoxShadow> _getBoxShadowList() {
    if (_boxShadow != null) {
      return [_boxShadow];
    } else {
      return null;
    }
  }

  void _configureTimer() {
    if (widget.duration != null) {
      if (timer != null) {
        timer.cancel();
      }
      timer = new Timer(widget.duration, () {
        _popController.reverse();
      });
    } else {
      if (timer != null) {
        timer.cancel();
      }
    }
  }

  @override
  void initState() {
    super.initState();

    Alignment initialAlignment;
    Alignment endAlignment;

    switch (widget.flushbarPosition) {
      case FlushbarPosition.TOP:
        {
          initialAlignment = new Alignment(-1.0, -2.0);
          endAlignment = new Alignment(-1.0, -1.0);
          barInsets = EdgeInsets.only(top: 24.0);
          _setBoxShadow();

          break;
        }
      case FlushbarPosition.BOTTOM:
        {
          initialAlignment = new Alignment(-1.0, 2.0);
          endAlignment = new Alignment(-1.0, 1.0);
          barInsets = EdgeInsets.only(top: 0.0);
          _setBoxShadow();

          break;
        }
    }

    _configurePopAnimation(initialAlignment, endAlignment);
    _configurePulseAnimation();
    _configureBlinkAnimation();
  }

  void _configurePopAnimation(Alignment initialAlignment, Alignment endAlignment) {
    _popController = AnimationController(vsync: this, duration: Duration(seconds: 1));

    _popAnimation = AlignmentTween(begin: initialAlignment, end: endAlignment).animate(new CurvedAnimation(
        parent: _popController, curve: widget.forwardAnimationCurve, reverseCurve: widget.reverseAnimationCurve));

    _popAnimation.addStatusListener(_animationStatusListener);

    _popController.addListener(() {
      setState(() {});
    });
  }

  void _configurePulseAnimation() {
    _fadeController = AnimationController(vsync: this, duration: _duration);
    _fadeAnimation = new Tween(begin: _initialOpacity, end: _finalOpacity).animate(
      new CurvedAnimation(
        parent: _fadeController,
        curve: Curves.linear,
      ),
    );

    _fadeController.addStatusListener((status) {
      if (status == AnimationStatus.completed) {
        _fadeController.reverse();
      }
      if (status == AnimationStatus.dismissed) {
        _fadeController.forward();
      }
    });

    _fadeController.forward();
  }

  void _configureBlinkAnimation() {
    _blinkController = AnimationController(vsync: this, duration: Duration(milliseconds: 500));
    _blinkAnimation = new Tween(begin: 1.0, end: 0.0)
        .animate(new CurvedAnimation(parent: _blinkController, curve: Curves.decelerate));

    _blinkController.addStatusListener((AnimationStatus status) {
      if (status == AnimationStatus.completed) {
        _blinkController.reverse();
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return new Align(
      heightFactor: 1.0,
      child: new AlignTransition(
        alignment: _popAnimation,
        child: _getFlushbar(),
      ),
    );
  }

  void _setBoxShadow() {
    switch (widget.flushbarPosition) {
      case FlushbarPosition.TOP:
        {
          if (widget.shadowColor != null) {
            _boxShadow = BoxShadow(
              color: widget.shadowColor,
              offset: Offset(0.0, 2.0),
              blurRadius: 3.0,
            );
          }

          break;
        }
      case FlushbarPosition.BOTTOM:
        {
          if (widget.shadowColor != null) {
            _boxShadow = BoxShadow(
              color: widget.shadowColor,
              offset: Offset(0.0, -0.7),
              blurRadius: 3.0,
            );
          }

          break;
        }
    }
  }

  @override
  void dispose() {
    _popController.dispose();
    _fadeController.dispose();
    _blinkController.dispose();
    super.dispose();
  }

  /// This string is a workaround until Dismissible supports a returning item
  String dismissibleKeyGen = "";

  Widget _getFlushbar() {
    if (widget.isDismissible) {
      return new Dismissible(
        key: Key(dismissibleKeyGen),
        onDismissed: (dismissDirection) {
          dismissibleKeyGen += "1";
          _resetAnimations();
        },
        child: (widget.userInputTextField != null) ? _generateInputFlushbar() : _generateFlushbar(),
      );
    } else {
      return _generateInputFlushbar() ?? _generateFlushbar();
    }
  }

  Widget _generateInputFlushbar() {
    return new FadeTransition(
      opacity: _blinkAnimation,
      child: new DecoratedBox(
        decoration: new BoxDecoration(
          color: widget.backgroundColor,
          gradient: widget.backgroundGradient,
          boxShadow: _getBoxShadowList(),
        ),
        child: new Padding(
          padding: barInsets,
          child: new Padding(
            padding: const EdgeInsets.only(left: 16.0, right: 16.0, bottom: 16.0, top: 16.0),
            child: widget.userInputTextField,
          ),
        ),
      ),
    );
  }

  Widget _generateFlushbar() {
    return new FadeTransition(
      opacity: _blinkAnimation,
      child: new DecoratedBox(
        decoration: new BoxDecoration(
          color: widget.backgroundColor,
          gradient: widget.backgroundGradient,
          boxShadow: _getBoxShadowList(),
        ),
        child: new Padding(
          padding: barInsets,
          child: new Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              widget.linearProgressIndicator ?? _emptyWidget,
              new Row(mainAxisSize: MainAxisSize.max, children: _getRowLayout()),
            ],
          ),
        ),
      ),
    );
  }

  List<Widget> _getRowLayout() {
    if (widget.icon == null && widget.mainButton == null) {
      return [
        new Expanded(
          flex: 1,
          child: new Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: <Widget>[
              new Padding(
                padding: const EdgeInsets.only(top: 16.0, left: 16.0, right: 16.0),
                child: widget.titleText ?? _getDefaultTitleText(),
              ),
              new Padding(
                padding: const EdgeInsets.only(top: 8.0, left: 16.0, right: 16.0, bottom: 16.0),
                child: widget.messageText ?? _getDefaultNotificationText(),
              ),
            ],
          ),
        ),
      ];
    } else if (widget.icon != null && widget.mainButton == null) {
      return <Widget>[
        new Expanded(
          flex: 1,
          child: _getIcon(),
        ),
        new Expanded(
          flex: 6,
          child: new Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: <Widget>[
              new Padding(
                padding: const EdgeInsets.only(top: 16.0, left: 8.0, right: 8.0),
                child: widget.titleText ?? _getDefaultTitleText(),
              ),
              new Padding(
                padding: const EdgeInsets.only(top: 8.0, left: 8.0, right: 8.0, bottom: 16.0),
                child: widget.messageText ?? _getDefaultNotificationText(),
              ),
            ],
          ),
        ),
      ];
    } else if (widget.icon == null && widget.mainButton != null) {
      return <Widget>[
        new Expanded(
          flex: 7,
          child: new Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: <Widget>[
              new Padding(
                padding: const EdgeInsets.only(top: 16.0, left: 16.0, right: 8.0),
                child: widget.titleText ?? _getDefaultTitleText(),
              ),
              new Padding(
                padding: const EdgeInsets.only(top: 8.0, left: 16.0, right: 8.0, bottom: 16.0),
                child: widget.messageText ?? _getDefaultNotificationText(),
              ),
            ],
          ),
        ),
        new Expanded(
          flex: 2,
          child: new Padding(
            padding: const EdgeInsets.only(right: 8.0),
            child: _getMainActionButton(),
          ),
        ),
      ];
    } else {
      return <Widget>[
        new Expanded(flex: 2, child: _getIcon()),
        new Expanded(
          flex: 6,
          child: new Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: <Widget>[
              new Padding(
                padding: const EdgeInsets.only(top: 16.0, left: 8.0, right: 8.0),
                child: widget.titleText ?? _getDefaultTitleText(),
              ),
              new Padding(
                padding: const EdgeInsets.only(top: 8.0, left: 8.0, right: 8.0, bottom: 16.0),
                child: widget.messageText ?? _getDefaultNotificationText(),
              ),
            ],
          ),
        ),
        new Expanded(
          flex: 2,
          child: new Padding(
            padding: const EdgeInsets.only(right: 8.0),
            child: _getMainActionButton(),
          ) ??
              _emptyWidget,
        ),
      ];
    }
  }

  Widget _getIcon() {
    if (widget.icon != null) {
      return FadeTransition(
        opacity: _fadeAnimation,
        child: widget.icon,
      );
    } else {
      return _emptyWidget;
    }
  }

  Text _getDefaultTitleText() {
    return new Text(
      widget.title ?? "",
      style: TextStyle(fontSize: 16.0, color: Colors.white, fontWeight: FontWeight.bold),
    );
  }

  Text _getDefaultNotificationText() {
    return new Text(
      widget.message ?? "",
      style: TextStyle(fontSize: 16.0, color: Colors.white),
    );
  }

  FlatButton _getMainActionButton() {
    if (widget.mainButton != null) {
      return widget.mainButton;
    } else {
      return null;
    }
  }
}

/// Indicates if flushbar is going to start at the [TOP] or at the [BOTTOM]
enum FlushbarPosition { TOP, BOTTOM }

/// Indicates the animation status
/// [FlushbarStatus.SHOWING] Flushbar has stopped and the user can see it
/// [FlushbarStatus.DISMISSED] Flushbar has stopped and the user can't see it
/// [FlushbarStatus.IS_APPEARING] Flushbar is moving towards [FlushbarStatus.SHOWING]
/// [FlushbarStatus.IS_HIDING] Flushbar is moving towards [] [FlushbarStatus.DISMISSED]
/// [FlushbarStatus.PURGED] Flushbar is discarded and won't move anymore
enum FlushbarStatus { SHOWING, DISMISSED, IS_APPEARING, IS_HIDING, PURGED }
